using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AutoShaderSourceGenerator;

[Generator]
public class AutoShaderSourceGenerator : IIncrementalGenerator {
    private const string EMPTY_TYPE = "Empty";
    private const string INTERFACE = "IAutoShader";

    public static void Execute(SourceProductionContext context, INamedTypeSymbol type) {
        var namespaceStr = type.ContainingNamespace.ToString();

        var args = type.Interfaces.Single(x => x.Name == INTERFACE).TypeArguments;

        if (args.Length != 4) {
            throw new($"{INTERFACE} must have all type arguments");
        }

        var hasAnyStatic = args[0].Name != EMPTY_TYPE || args[1].Name != EMPTY_TYPE;
        var hasAnyInstance = args[2].Name != EMPTY_TYPE || args[3].Name != EMPTY_TYPE;

        var instanceOffset = hasAnyStatic ? 1 : 0;

        var interfaceType = $"{INTERFACE}<{args[0].Name}, {args[1].Name}, {args[2].Name}, {args[3].Name}>";

        var src = $$"""
                    // <auto-generated/>

                    using ShaderGen;
                    using SCPCB.Graphics.Shaders.Utility;
                    {{
                        string.Join("\n", args
                            .Select(x => x.ContainingNamespace?.ToString())
                            .Where(x => x != null && x != namespaceStr)
                            .Distinct()
                            .Select(x => $"using {x};"))
                    }}

                    namespace {{namespaceStr}};

                    [ShaderClass]
                    public partial class {{type.Name}} {
                        {{ValueOrEmpty(args[0], 0)}} VertexBlock;
                        {{ValueOrEmpty(args[1], 0)}} FragmentBlock;

                        {{ValueOrEmpty(args[2], instanceOffset)}} InstanceVertexBlock;
                        {{ValueOrEmpty(args[3], instanceOffset)}} InstanceFragmentBlock;
                        
                        [ResourceIgnore] {{args[0].Name}} {{interfaceType}}.VertexBlock => VertexBlock;
                        [ResourceIgnore] {{args[1].Name}} {{interfaceType}}.FragmentBlock => FragmentBlock;
                    
                        [ResourceIgnore] {{args[2].Name}} {{interfaceType}}.InstanceVertexBlock => InstanceVertexBlock;
                        [ResourceIgnore] {{args[3].Name}} {{interfaceType}}.InstanceFragmentBlock => InstanceFragmentBlock;

                        const int MATERIAL_OFFSET = {{instanceOffset + (hasAnyInstance ? 1 : 0)}};
                    }
                    """;

        string ValueOrEmpty(ITypeSymbol symbol, int set)
            => $"[{(symbol.Name == EMPTY_TYPE ? "ResourceIgnore" : $"ResourceSet({set})")}] public {symbol.Name}";

        context.AddSource($"{type.Name}.generated.cs", src);
    }

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var autoShaderTypes = context.SyntaxProvider
            .CreateSyntaxProvider((s, _) => s is ClassDeclarationSyntax cds && cds.BaseList?.Types
                    .Any(x => x.Type.GetFirstToken().ValueText == INTERFACE) == true,
                (ctx, _) => ctx.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)ctx.Node)!);
        context.RegisterSourceOutput(autoShaderTypes, Execute);
    }
}
