using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AutoShaderSourceGenerator {
    [Generator]
    public class AutoShaderSourceGenerator : ISourceGenerator {
        private const string EMPTY_TYPE = "Empty";
        private const string INTERFACE = "IAutoShader";

        public void Execute(GeneratorExecutionContext context) {
            var syntaxReceiver = (SyntaxReceiver)context.SyntaxReceiver!;

            foreach (var cds in syntaxReceiver.Classes) {
                var semantic = context.Compilation.GetSemanticModel(cds.SyntaxTree);

                var type = semantic.GetDeclaredSymbol(cds)!;
                var namespaceStr = type.ContainingNamespace.ToString();

                var args = type.Interfaces.Single(x => x.Name == INTERFACE).TypeArguments;

                if (args.Length != 4) {
                    throw new($"{INTERFACE} must have all type arguments");
                }

                var hasAnyStatic = args[0].Name != EMPTY_TYPE || args[1].Name != EMPTY_TYPE;
                var hasAnyInstance = args[2].Name != EMPTY_TYPE || args[3].Name != EMPTY_TYPE;

                var instanceOffset = hasAnyStatic ? 1 : 0;

                var src = $$"""
                    // <auto-generated/>

                    using ShaderGen;
                    {{
                        string.Join("\n", args
                            .Select(x => x.ContainingNamespace?.ToString())
                            .Where(x => x != null && x != namespaceStr)
                            .Distinct()
                            .Select(x => $"using {x};"))
                    }}
                    
                    namespace {{namespaceStr}};

                    [ShaderClass]
                    public partial class {{type.Name}} {
                        {{ValueOrEmpty(args[0], 0)}} VertexBlock { get; }
                        {{ValueOrEmpty(args[1], 0)}} FragmentBlock { get; }

                        {{ValueOrEmpty(args[2], instanceOffset)}} InstanceVertexBlock { get; }
                        {{ValueOrEmpty(args[3], instanceOffset)}} InstanceFragmentBlock { get; }

                        const int MATERIAL_OFFSET = {{instanceOffset + (hasAnyInstance ? 1 : 0)}};
                    }
                    """;

                string ValueOrEmpty(ITypeSymbol symbol, int set)
                    => $"[{(symbol.Name == EMPTY_TYPE ? "ResourceIgnore" : $"ResourceSet({set})")}] public {symbol.Name}";

                context.AddSource($"{type.Name}.generated.cs", src);
            }
        }

        public void Initialize(GeneratorInitializationContext context) {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }
    }

    public class SyntaxReceiver : ISyntaxReceiver {
        public List<ClassDeclarationSyntax> Classes { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode) {
            if (syntaxNode is ClassDeclarationSyntax { BaseList: not null } cds
                && cds.BaseList.Types.Any(x => x.Type.GetFirstToken().ValueText == "IAutoShader")) {
                Classes.Add(cds);
            }
        }
    }
}
